========================
轻量级锁
------------------------
-嵌入在线程栈中的对象
BasicObjectLock
1.BasicLock    markOop_displaced_header 存放的主要的内容就是displaced_header对象头
2.ptr to obj hold the lock 指向持有锁的对象的指针
========================
轻量级锁
------------------------
■ 普通的锁处理性能不够理想,轻量级锁是一种快速的锁定方法。
■ 如果对象没有被锁定
- 将对象头的Mark指针保存到锁对象中
- 将对象头设置为指向锁的指针（在线程栈空间中）
lock->set_displaced_header(mark);
if(mark ==(markOop) Atomic::cmpxchg_ptr(lock,obj()->mark_addr(),mark))
{
    TEVENT(slow_enter:release stacklock);
    return;
}
lock位于线程中
========================
轻量级锁
------------------------
■ 如果轻量级锁失败,表示存在竞争,升级为重量级锁（常规锁）
■ 在没有锁竞争的前提下,减少传统锁使用OS互斥量产生的性能损耗
■ 在竞争激烈时,轻量级锁会多做很多额外操作,导致性能下降
=========================
自旋锁-在存在竞争时，前面讲的都是假定没有竞争时候使用的
-------------------------
■当竞争存在时,如果线程可以很快获得锁,那么可以不在OS层挂起线程,让线程做几个空操作(自旋）
■JDK1.6中-XX:+UseSpinning开启
■JDK1.7中,去掉此参数,改为内置实现
■如果同步块很长,自旋失败,会降低系统性能
■如果同步块很短,自旋成功,节省线程挂起切换时间,提升系统性能
==========================
偏向锁,轻量级锁,自旋锁总结
--------------------------
■不是Java语言层面的锁优化方法
■内置于JVM中的获取锁的优化方法和获取锁的步骤
-偏向锁可用会先尝试偏向锁
-轻量级锁可用会先尝试轻量级锁
-以上都失败,尝试自旋锁
- 再失败,尝试普通锁,使用OS互斥量在操作系统层挂起
===========================


